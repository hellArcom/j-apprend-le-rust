//Compiler et exécuter : cargo run
//Compiler sans éxécuter : cargo build
// Compiler sans cargo : restc "nomdufichier.rs"

fn main() {} //fonction principal (obligatoire)

println!("Hello World"); // Afficher du texte avec un a la ligne

////////////////////////////////////////////
///////// LES VARIABLE /////////////////////
////////////////////////////////////////////
let mut nom_variable = valeur //exemple
let //serent a déclarer une variable 
let mut // mut pour pouvoir changer la valeur plus tard


/////////////////////////////////////////////
////////// LES TYPES DE DONNER /////////////
////////////////////////////////////////////

//Rust connait automatiquement le types de variable sauf quand il peut pas savoir donc : 
let age: i32 = 25;
let point: u8 = 100;

////////////////////Types de données de base ///////////////////////////////////
//#########################################################################
//### Type	    Bits	Signe	Plage                               
//###________________________________________________________________________
//###  i8	      8      Oui	-128 à 127
//###________________________________________________________________________
//###  u8	      8      Non	0 à 255
//###________________________________________________________________________
//### i32	     32   	 Oui	-2^31 à 2^31 - 1
//###________________________________________________________________________
//###  u32	     32	     Non	0 à 2^32 - 1
//###________________________________________________________________________
//###  i64 	     64	     Oui	...
//###________________________________________________________________________
//###  usize	selon l’archi (64 bits en général)	utilisé pour indexer
//#########################################################################
// u = SANS les "-" nombre négatif
// i = AVEC les "-" nombre négatif
// f = nombre flottant (avec virgule)
// 8 = 8 bits
// 32 = 32 bits
// 64 = 64 bits

//types de donner
&str  :  rapide et léger, mais pas modifiable.
String : dynamique et modifiable (plus lourd, mais plus flexible).
